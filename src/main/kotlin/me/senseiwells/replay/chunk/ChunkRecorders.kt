package me.senseiwells.replay.chunk

import me.senseiwells.replay.ServerReplay
import me.senseiwells.replay.recorder.RecorderRecoverer
import net.minecraft.resources.ResourceKey
import net.minecraft.server.MinecraftServer
import net.minecraft.server.level.ServerLevel
import net.minecraft.world.level.ChunkPos
import net.minecraft.world.level.Level
import net.minecraft.world.level.levelgen.structure.BoundingBox
import java.util.concurrent.CompletableFuture

/**
 * This object manages all [ChunkRecorder]s.
 */
object ChunkRecorders {
    private val chunks = LinkedHashMap<ChunkArea, ChunkRecorder>()
    private val chunksByName = LinkedHashMap<String, ChunkRecorder>()
    private val closing = HashMap<String, ChunkRecorder>()

    /**
     * This creates a [ChunkRecorder].
     *
     * @param level The level which the recorder is in.
     * @param from The chunk corner to record from.
     * @param to The chunk corner to record to.
     * @param name The name of the recorder.
     * @return The created recorder.
     */
    @JvmStatic
    fun create(level: ServerLevel, from: ChunkPos, to: ChunkPos, name: String): ChunkRecorder {
        return this.create(ChunkArea(level, from, to), name)
    }

    /**
     * This creates a [ChunkRecorder].
     *
     * @param area The chunk area to record.
     * @param name The name of the recorder, one will be generated by if not provided.
     * @return The created recorder.
     */
    @JvmStatic
    @JvmOverloads
    fun create(area: ChunkArea, name: String = generateName(area)): ChunkRecorder {
        if (this.chunks.containsKey(area)) {
            throw IllegalArgumentException("Recorder for chunk area already exists")
        }
        if (this.chunksByName.containsKey(name)) {
            throw IllegalArgumentException("Recorder with name already exists")
        }

        val recorder = ChunkRecorder(
            area,
            name,
            ServerReplay.config.chunkRecordingPath.resolve(name)
        )
        this.chunks[area] = recorder
        this.chunksByName[name] = recorder
        RecorderRecoverer.add(recorder)
        return recorder
    }

    /**
     * Whether a chunk recorder with a given [name] exists.
     *
     * @param name The name to check.
     * @return Whether a chunk recorder with that name exists.
     */
    @JvmStatic
    fun has(name: String): Boolean {
        return this.chunksByName.containsKey(name)
    }

    /**
     * Whether a chunk recorder for the given [area] exists.
     *
     * @param area The area to check.
     * @return Whether a chunk recorder with that area exists.
     */
    @JvmStatic
    fun has(area: ChunkArea): Boolean {
        return this.chunks.containsKey(area)
    }

    /**
     * Checks whether the given [area] and [name] is available
     * or whether at least one is already taken.
     *
     * @param area The area to check.
     * @param name The name to check.
     * @return Whether the area and name are both available.
     */
    @JvmStatic
    fun isAvailable(area: ChunkArea, name: String): Boolean {
        return !this.has(area) && !this.has(name)
    }

    /**
     * Gets a [ChunkRecorder] for a given name.
     *
     * @param name The name of the recorder.
     * @return The recorder instance with the given name, null if it doesn't exist.
     */
    @JvmStatic
    fun get(name: String): ChunkRecorder? {
        return this.chunksByName[name]
    }

    /**
     * Gets a [ChunkRecorder] for a given [area].
     *
     * @param area The area of the recorder.
     * @return The recorder instance with the given area, null if it doesn't exist.
     */
    @JvmStatic
    fun get(area: ChunkArea): ChunkRecorder? {
        return this.chunks[area]
    }

    /**
     * Gets all the [ChunkRecorder]s that contain a given [chunk] in the given [level].
     *
     * @param level The level to check in.
     * @param chunk The position the recorder must contain.
     * @return A list of chunk recorders.
     */
    @JvmStatic
    fun containing(level: ResourceKey<Level>, chunk: ChunkPos): List<ChunkRecorder> {
        return this.chunks.values.filter { it.chunks.contains(level, chunk) }
    }

    /**
     * Gets all the [ChunkRecorder]s that intersect a given [box] in the given [level].
     *
     * @param level The level to check in.
     * @param box The bounding box the recorder must intersect with.
     * @return A list of chunk recorders.
     */
    @JvmStatic
    @Suppress("unused")
    fun intersecting(level: ResourceKey<Level>, box: BoundingBox): List<ChunkRecorder> {
        return this.chunks.values.filter { it.chunks.intersects(level, box) }
    }

    /**
     * Gets a collection of all the currently recording chunk recorders.
     *
     * @return A collection of all the chunk recorders.
     */
    @JvmStatic
    fun recorders(): Collection<ChunkRecorder> {
        return ArrayList(this.chunks.values)
    }

    /**
     * Gets a collection of all the currently closing chunk recorders.
     *
     * @return A collection of all the closing chunk recorders.
     */
    @JvmStatic
    fun closing(): Collection<ChunkRecorder> {
        return ArrayList(this.closing.values)
    }

    /**
     * This updates a [ChunkRecordable] adding and removing chunk
     * recordings that should be recording it.
     *
     * @param recordable The recordable to update.
     * @param level The level in which the recordable should be recorded in.
     * @param chunk The chunk in which the recordable is in.
     * @see ChunkRecordable
     */
    @JvmStatic
    fun updateRecordable(
        recordable: ChunkRecordable,
        level: ResourceKey<Level>,
        chunk: ChunkPos
    ) {
        this.updateRecordable(recordable) { it.contains(level, chunk) }
    }

    /**
     * This updates a [ChunkRecordable] adding and removing chunk
     * recordings that should be recording it.
     *
     * @param recordable The recordable to update.
     * @param level The level in which the recordable should be recorded in.
     * @param box The bounding box of the recordable.
     * @see ChunkRecordable
     */
    @JvmStatic
    fun updateRecordable(
        recordable: ChunkRecordable,
        level: ResourceKey<Level>,
        box: BoundingBox
    ) {
        this.updateRecordable(recordable) { it.intersects(level, box) }
    }

    private fun updateRecordable(
        recordable: ChunkRecordable,
        predicate: (ChunkArea) -> Boolean
    ) {
        val existing = recordable.getRecorders()
        for (recorder in this.chunks.values) {
            if (predicate(recorder.chunks)) {
                if (!existing.contains(recorder)) {
                    recordable.addRecorder(recorder)
                }
            } else if (existing.contains(recorder)) {
                recordable.removeRecorder(recorder)
            }
        }
    }

    /**
     * This generates a name for a given [area].
     *
     * @param area The chunk area.
     * @return The name for the given [area].
     */
    fun generateName(area: ChunkArea): String {
        return "Chunks (${area.from.x}, ${area.from.z}) to (${area.to.x}, ${area.to.z})"
    }

    internal fun remove(area: ChunkArea): ChunkRecorder? {
        val recorder = this.chunks.remove(area)
        if (recorder != null) {
            this.chunksByName.remove(recorder.getName())
        }
        return recorder
    }

    internal fun close(
        server: MinecraftServer,
        recorder: ChunkRecorder,
        future: CompletableFuture<Long>
    ) {
        this.remove(recorder.chunks)
        this.closing[recorder.recorderName] = recorder
        future.thenRunAsync({
            this.closing.remove(recorder.recorderName)
            RecorderRecoverer.remove(recorder)
        }, server)
    }
}